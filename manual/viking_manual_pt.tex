\documentclass{extreport}
\usepackage[a4paper, top=3cm, bottom=3cm]{geometry}
%\usepackage[latin1]{inputenc}
\usepackage{setspace}
\usepackage{fancyhdr}
\usepackage{tocloft}
\usepackage{fixltx2e}
\usepackage[inline]{enumitem}
\usepackage[brazilian]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{multicol}
\usepackage{viking_asm}
\usepackage{color}
\usepackage{xcolor}
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}; should come as last argument
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=t,                    % sets the caption-position to top
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  frame=none,	                   % adds a frame around the code (none, single)
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  keywordstyle=[2]\color{black},
  keywordstyle=[3]\color{olive},
  language=[viking]Assembler,                 % the language of the code
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=8pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}

\begin{document}

\pagestyle{empty}
\title{\textbf{Viking CPU - Manual de referência v0.5}}
\author{Sérgio Johann Filho}

\maketitle

%\thispagestyle{empty}
%\thanks{Essa mensagem de agredecimento foi intencionalmente deixada em branco.}
%\newpage

\renewcommand{\cftchapdotsep}{\cftdotsep}
\tableofcontents

\pagestyle{fancy}
\fancyhf{}
\lhead[]{\thepage}
\rhead[\thepage]{}
\pagenumbering{arabic}
\onehalfspacing

%\chapter*{Preface}
%Write the preface here.

\newpage
\thispagestyle{empty}

\chapter{A arquitetura Viking}
Viking é uma arquitetura simples, construída de acordo com a filosofia RISC. Essa arquitetura foi planejada com o objetivo de servir como ponto de partida para um conjunto de instruções básico extensível, em que uma quantidade reduzida de \textit{hardware} é necessário para implementar seu conjunto de operações\footnote{O conjunto de instruções foi definido com o intuito de minimizar a complexidade da arquitetura e de forma que possa facilmente sintetizar operações mais complexas através de poucas operações básicas.}, e ainda possuir funcionalidade suficiente para a execução de \textit{software} de alto nível. Por exemplo, o banco de registradores possui poucas entradas, poucos multiplexadores são necessários, não existem qualificadores de estado\footnote{A arquitetura possui uma excessão, que é a geração e inclusão condicional de \textit{carry} para operações aritméticas e de deslocamento.} de operações, unidades multiplicação e divisão não foram definidas, tampouco uma unidade de deslocamento (\textit{barrel shifter}). Esse processador pode ser implementado em variantes de 16 e 32 bits, sendo que a diferença entre as duas se dá apenas com relação ao tamanho dos registradores do seu banco, o que não altera o conjunto de instruções básico.

Um pequeno número de operações é definido no conjunto de instruções da arquitetura Viking (20 operações básicas). Apesar do pequeno número de instruções, estas são poderosas o suficiente para realizarem todas as operações de máquinas com um maior número de instruções. Para que isso seja possível, muitas vezes uma instrução é utilizada de modo pouco ortodoxo ou uma combinação de instruções implementam um único comportamento. As operações são separadas em quatro classes distintas:

\begin{enumerate}
\item \textit{Computação} (AND, OR, XOR, SLT, SLTU, ADD, ADC, SUB, SBC, LDR, LDC)
\item \textit{Deslocamento e rotação} (LSR, ASR, ROR)
\item \textit{Carga e armazenamento} (LDB, STB, LDW, STW)
\item \textit{Desvios condicionais} (BEZ, BNZ)
\end{enumerate}

Seguindo a filosofia RISC, as instruções são definidas em uma codificação que utiliza apenas dois formatos de instrução, com um tamanho fixo de 16 bits por instrução. Assim, a lógica necessária para a decodificação de instruções é reduzida significativamente, comparado ao que seria necessário para decodificar instruções com um tamanho variável. Além disso, um tamanho de 16 bits permite uma boa densidade de código, quando comparado a outros ISAs que possuem instruções de tamanho fixo porém com 32 bits.

\section{Registradores}
Assim como outros processadores RISC, o processador Viking é definido como uma arquitetura baseada em operações de carga e armazenamento (\textit{load/store}) para acesso à memória de dados. Para que operações lógicas e aritméticas possam ser executadas, é necessário que os operandos sejam trazidos da memória ou carregados como constantes em um ou mais registradores de propósito geral (GPRs).

São definidos 8 registradores (\textit{r0 - r7}) e estes podem ser utilizados para qualquer finalidade, sendo apenas recomendado seu uso em função das convenções apresentadas na tabela abaixo e detalhadas na Seção \ref{ref:fcalls_conv} para a chamada de funções. Os registradores \textit{r0} (\textit{at}) e \textit{r7} (\textit{sp}) são respectivamente utilizados como \textit{temporário} e \textit{ponteiro de pilha}. Esses registradores não devem ser tratados da mesma forma que os outros. O temporário é usado por pseudo operações (apresentadas na Seção \ref{ref:pseudo_ops}) e o ponteiro de pilha para armazenamento de dados e chamadas de função. Outro papel desse registrador é a implementação de desvios incondicionais, uma vez que é seguro assumir que seu valor nunca será zero durante a execução normal de um programa.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.5cm}|p{1.6cm}|p{1.6cm}|p{3.0cm}|}
\hline
\bf{Registrador} & \bf{Nome} & \bf{Apelido} & \bf{Papel} 		\\ \hline \hline
\texttt{0}	& \texttt{r0}	& \texttt{at}	& Especial		 \\ \hline
\texttt{1}	& \texttt{r1}	& \texttt{r1}	& Uso geral	 	\\ \hline
\texttt{2}	& \texttt{r2}	& \texttt{r2}	& Uso geral 		\\ \hline
\texttt{3}	& \texttt{r3}	& \texttt{r3}	& Uso geral 		\\ \hline
\texttt{4}	& \texttt{r4}	& \texttt{r4}	& Uso geral 		\\ \hline
\texttt{5}	& \texttt{r5}	& \texttt{sr}	& Uso geral 		\\ \hline
\texttt{6}	& \texttt{r6}	& \texttt{lr}	& Uso geral	 	\\ \hline
\texttt{7}	& \texttt{r7}	& \texttt{sp}	& Especial	 	\\ \hline
\end{tabular}
\end{table}

Além dos 8 registradores de propósito geral (GPRs), é definido na arquitetura um registrador com a finalidade de contador de programa (PC). Esse registrador aponta para a instrução corrente do programa, e não pode ser modificado diretamente pelo programador. A cada instrução que é decodificada, o PC avança para a próxima posição. Desvios condicionais podem fazer com que o PC seja atualizado com o destino do desvio, caso tomado. As instruções possuem um tamanho de 16 bits, portanto o contador de programa é incrementado com esse tamanho.

\section{Formatos de instrução}
Existem apenas dois formatos de instrução definidos na arquitetura Viking (tipos R e I). Em instruções do tipo R, um registrador é definido como destino (\textit{Rst}) e dois registradores são definidos como fontes (\textit{RsA} e \textit{RsB}). Em instruções do tipo I, um registrador é definido como fonte e destino da operação (\textit{Rst}), e o segundo valor usado como fonte é obtido a partir do campo \textit{Immediate} codificado diretamente na instrução. Os índices utilizados para indexar o banco de registradores são codificados na instrução em 3 bits cada, o suficiente para referenciar 8 registradores por operando ou destino para escrita do resultado.

\subsection{Instruções tipo R}
Em instruções do tipo R os campos \textit{Opcode} (4 bits) e \textit{Op2} (2 bits) definem a operação específica. Nesse tipo de instrução três registradores são referenciados, e o papel desses registradores depende da classe à qual a instrução está associada. As instruções do tipo R possuem o campo \textit{Imm} com o valor fixo em 0.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{x x x x} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{x x} \\ \hline
\end{tabular}
\end{table}

A função dos campos adicionais em instruções do tipo R é definida como:

\begin{itemize}
\item \textit{Rst} - registrador destino (alvo) da operação;
\item \textit{RsA} - registrador Fonte 1 (Operando A);
\item \textit{RsB} - registrador Fonte 2 (Operando B ou base);
\subitem - Operando B em operações da classe computação
\subitem - Endereço base para instruções de carga e armazenamento e desvios;
\end{itemize}

Para instruções de deslocamento, o registrador Fonte 2 deve ser sempre \textit{r0}. O motivo para isso é que não é necessário codificar a quantidade a ser deslocada, uma vez que a arquitetura pode deslocar apenas 1 bit por instrução. Em instruções de carga, o registrador Fonte 1 deve ser sempre \textit{r0} e em instruções de armazenamento e desvios condicionais, o registrador alvo é sempre \textit{r0}.  Abaixo são apresentados alguns exemplos de instruções do tipo R, utilizando a sintaxe da linguagem de montagem apresentada no Capítulo \ref{ref:assembler}. Importante observar que em instruções de armazenamento e desvios condicionais \textit{Rst} deve ser \textit{r0}, em instruções de carga \textit{RsA} deve ser \textit{r0} e em deslocamentos \textit{RsB} deve ser \textit{r0}\footnote{O motivo para tais convenções é fixar no formato de instruções o papel dos registradores \textit{Rst}, \textit{RsA} e \textit{RsB}, evitando a utilização de multiplexadores adicionais. No tipo R, o primeiro registrador sempre é escrito, e os dois últimos sempre lidos. No tipo I, o primeiro é sempre lido e escrito.}.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{3.0cm}|p{6.0cm}|}
\hline
\bf{Operação} & \bf{Significado} \\ \hline \hline
\texttt{add r3,r1,r2} & r3 = r1 + r2 \\ \hline
\texttt{ldb r3,r0,r2} & r3 = MEM[r2] \\ \hline
\texttt{stw r0,r1,r2} & MEM[r2] = r1 \\ \hline
\texttt{and r2,r3,r4} & r2 = r3 and r4 \\ \hline
\texttt{bez r0,r2,r3} & if (r2 == zero) PC = r3 \\ \hline
\texttt{slt r3,r1,r2} & if (r1 < r2) r3 = 1, else r3 = 0 \\ \hline
\texttt{lsr r5,r3,r0} & r5 = r3 $>>$ 1 \\ \hline
\end{tabular}
\end{table}

\subsection{Instruções tipo I}
Em instruções do tipo I o campo \textit{Opcode} (4 bits) define a operação específica. Nesse tipo de instrução um registrador é referenciado, e o papel desse registrador depende da classe à qual a instrução está associada. As instruções do tipo I possuem o campo \textit{Imm} com o valor fixo em 1.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{x x x x} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}

A função dos campos adicionais em instruções do tipo I é definida como:

\begin{itemize}
\item \textit{Rst} - registrador Fonte 1 e destino;
\item \textit{Immediate} - campo com valor imediato;
\subitem - Fonte 2 em instruções da classe computação;
\subitem - Endereço relativo ao contador de programa em desvios;
\end{itemize}

Para desvios condicionais, endereço efetivo é calculado somando-se o valor atual do contador de programa (PC) ao campo \textit{Immediate} (extendido em sinal\footnote{A implementação de extensão de sinal é apresentada na Seção \ref{ref:sign_ext}.} e representado em complemento de 2). Dessa forma, é possível realizar desvios relativos ao PC de $\pm$128 bytes\footnote{No futuro o campo \textit{Immediate} poderá codificar apenas a magnitude alinhada, o que aumenta o alcance dos desvios relativos para $\pm$256 bytes.}, o suficiente para lidar com a maior parte dos casos que envolvem saltos de tamanho reduzido, como em comandos de seleção e laços curtos. Abaixo são apresentados alguns exemplos de instruções do tipo I, utilizando a sintaxe da linguagem de montagem.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{3.0cm}|p{6.0cm}|}
\hline
\bf{Operação} & \bf{Significado} \\ \hline \hline
\texttt{add r5,10} & r5 = r5 + 10 \\ \hline
\texttt{or r2,1} & r2 = r2 or 1 \\ \hline
\texttt{xor r5,-1} & r5 = r5 xor -1 = not r5 \\ \hline
\texttt{ldr r3,5} & r3 = 5 \\ \hline
\texttt{ldc r3,10} & r3 = (r3 $<<$ 8) or 10 \\ \hline
\texttt{slt r4,10} & if (r4 < 10) r4 = 1, else r4 = 0 \\ \hline
\texttt{bez r4,28} & if (r4 == zero) PC = PC + 28 \\ \hline
\end{tabular}
\end{table}

\section{Modos de endereçamento}

Apenas três modos de endereçamento são utilizados na arquitetura, sendo esses:

\begin{enumerate}
\item \textit{Registrador}
\item \textit{Imediato}
\item \textit{Relativo ao PC}
\end{enumerate}

O primeiro modo (registrador) é utilizado por instruções do tipo R apenas. Instruções que fazem uso desse modo pertencem às classes computação, deslocamento, carga e armazenamento e desvios condicionais. O segundo modo (imediato) é utilizado por instruções do tipo I apenas, classe computação. O último modo (relativo ao PC) é utilizado por instruções do tipo I, classe desvios condicionais.

Dois modos de endereçamento bastante comuns são os modos \textit{direto} e \textit{indireto}. A arquitetura Viking não define esses modos de endereçamento, uma vez que a memória de dados é acessada exclusivamente por operações de carga e armazenamento. No entanto, tais modos podem ser emulados\footnote{No Capítulo \ref{ref:pseudo_ops} são apresentadas pseudo operações que emulam o modo de endereçamento direto.} com o uso de múltiplas instruções de carga, permitindo acesso à memória pelo número de indireções desejado. Outros modos de endereçamento como \textit{base + deslocamento}, \textit{base + índice}, \textit{indireto à registrador}, \textit{indireto à memória} e \textit{auto incremento}, entre outros, não foram definidos com o objetivo de simplificar a arquitetura.

\section{Conjunto de instruções}

O conjunto de instruções básico definido na arquitetura é apresentado a seguir. Diversos códigos de operação são reservados para extensões futuras, como operações aritméticas, carga e armazenamento e desvios, além de instruções mais poderosas com tamanho de 32 bits.

As operações definidas no conjunto de instruções básico permitem que operações não elementares possam ser geradas a partir de sequências curtas. Como as instruções possuem tamanho de 16 bits, a densidade do código é boa.

\subsection{Computação}

\subsubsection{AND - bitwise logical product}
Realiza o produto lógico de dois valores e armazena o resultado em um registrador.

\begin{itemize}
\item AND Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] and GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 0 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item AND Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[Rst] and ZEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 0 0 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{OR - bitwise logical sum}
Realiza a soma lógica de dois valores e armazena o resultado em um registrador.

\begin{itemize}
\item OR Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] or GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 0 1} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item OR Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[Rst] or ZEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 0 0 1} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{XOR - bitwise logical difference}
Realiza a diferença lógica de dois valores e armazena o resultado em um registrador. No tipo I, o segundo valor possui extensão de sinal.

\begin{itemize}
\item XOR Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] xor GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item XOR Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[Rst] xor SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 0 1 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{SLT - set if less than}
Compara dois valores (com sinal, em complemento de 2). Se o primeiro for menor que o segundo, armazena 1 (verdadeiro) em um registrador. Senão, armazena 0 (falso). No tipo I, o segundo valor possui extensão de sinal. O cálculo do valor dessa instrução é definido por \texttt{SLT = N xor V}, resultante de uma subtra\c{c}\~{a}o realizada internamente e avaliação da diferença lógica dos qualificadores \textit{negative} e \textit{overflow}, também internos a ULA. O valor da condição \texttt{SLT} é armazenado no bit menos significativo do registrador destino, sendo os outros zerados.

\begin{itemize}
\item SLT Rst, RsA, RsB
\subitem \texttt{if (GPR[RsA] < GPR[RsB]) GPR[Rst] $\leftarrow$ 1}
\subitem \texttt{else GPR[Rst] $\leftarrow$ 0}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 1 1} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item SLT Rst, Immediate
\subitem \texttt{if (GPR[RsA] < SEXT(Immediate) GPR[Rst] $\leftarrow$ 1}
\subitem \texttt{else GPR[Rst] $\leftarrow$ 0}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 0 1 1} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{SLTU - set if less than (unsigned)}
Compara dois valores (sem sinal). Se o primeiro for menor que o segundo, armazena 1 (verdadeiro) em um registrador. Senão, armazena 0 (falso). No tipo I, o segundo valor possui extensão de sinal. O cálculo dessa instrução é definido por \texttt{SLTU = C}, resultante de uma subtra\c{c}\~{a}o realizada internamente e avaliação do qualificador \textit{carry} interno a ULA. O valor da condição \texttt{SLTU} é armazenado no bit menos significativo do registrador destino, sendo os outros zerados.

\begin{itemize}
\item SLTU Rst, RsA, RsB
\subitem \texttt{if (GPR[RsA] < GPR[RsB]) GPR[Rst] $\leftarrow$ 1}
\subitem \texttt{else GPR[Rst] $\leftarrow$ 0}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 0 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item SLTU Rst, Immediate
\subitem \texttt{if (GPR[RsA] < SEXT(Immediate) GPR[Rst] $\leftarrow$ 1}
\subitem \texttt{else GPR[Rst] $\leftarrow$ 0}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 1 0 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{ADD - add}
Soma dois valores e armazena o resultado em um registrador. No tipo I, o segundo valor possui extensão de sinal.

\begin{itemize}
\item ADD Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] + GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 0 1} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item ADD Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[Rst] + SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 1 0 1} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{ADC - add with carry}
Soma dois valores e armazena o resultado em um registrador. A soma inclui o \textit{carry} gerado pela última instrução.

\begin{itemize}
\item ADC Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] + GPR[RsB] + Carry}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 0 1} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 1} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{SUB - subtract}
Subtrai dois valores e armazena o resultado em um registrador. No tipo I, o segundo valor possui extensão de sinal.

\begin{itemize}
\item SUB Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] - GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}

\item SUB Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[Rst] - SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{0 1 1 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{SBC - subtract with carry}
Subtrai dois valores e armazena o resultado em um registrador. A subtração inclui o \textit{carry} gerado pela última instrução.

\begin{itemize}
\item SBC Rst, RsA, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ GPR[RsA] - GPR[RsB] - Carry}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{r r r} & \texttt{0 1} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{LDR - load register}
Carrega uma constante de 8 bits em um registrador. O valor carregado possui extensão de sinal, o que facilita a carga de constantes de pequeno valor ($\pm$128, em complemento de dois) com apenas uma instrução.

\begin{itemize}
\item LDR Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{1 0 0 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{LDC - load constant}
Carrega uma constante em um registrador. O valor carregado não possui extensão de sinal. Antes de carregar o valor nos 8 bits menos significativos de um registrador, o mesmo tem seu conteúdo deslocado à esquerda por 8 bits, o que permite a carga de constantes de valores maiores que $\pm$128 com múltiplas instruções.

\begin{itemize}
\item LDC Rst, Immediate
\subitem \texttt{GPR[Rst] $\leftarrow$ $GPR[Rst]_{<7/24:0>}$ \& ZEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{1 0 0 1} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsection{Deslocamento e rotação}
\subsubsection{LSR - logical shift right}
Realiza a o deslocamento lógico por 1 bit à direita e armazena o resultado em um registrador. O valor de \textit{carry} é modificado com o valor do \textit{bit} perdido.

\begin{itemize}
\item LSR Rst, RsA, r0
\subitem \texttt{GPR[Rst] $\leftarrow$ '0' \& $GPR[RsA]_{<15/31:1>}$}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{1 0 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0 0} & \texttt{0 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{ASR - arithmetic shift right}
Realiza a o deslocamento aritmético por 1 bit à direita e armazena o resultado em um registrador. O valor armazenado tem seu sinal mantido. O valor de \textit{carry} é modificado com o valor do \textit{bit} perdido.

\begin{itemize}
\item ASR Rst, RsA, r0
\subitem \texttt{GPR[Rst] $\leftarrow$ $GPR[RsA]_{15/31}$ \& $GPR[RsA]_{<15/31:1>}$}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{1 0 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0 0} & \texttt{0 1} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{ROR - rotate right through carry}
Realiza a rotação por 1 bit à direita e armazena o resultado em um registrador. O valor inserido no bit mais significativo é o valor de \textit{carry} gerado na última instrução. O novo valor de \textit{carry} é modificado com o valor do \textit{bit} perdido.

\begin{itemize}
\item ROR Rst, RsA, r0
\subitem \texttt{GPR[Rst] $\leftarrow$ Carry \& $GPR[RsA]_{<15/31:1>}$}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{1 0 1 0} & \texttt{0} & \texttt{r r r} & \texttt{r r r} & \texttt{0 0 0} & \texttt{1 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsection{Carga e armazenamento}
\subsubsection{LDB - load byte}
Carrega um byte da memória. O endereço é obtido a partir do registrador base \textit{RsB}. O valor é carregado na parte baixa do registrador destino \textit{Rst}, e possui extensão de sinal.

\begin{itemize}
\item LDB Rst, r0, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ SEXT(MEM[GPR[RsB]]\textsubscript{<7:0>})}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 0 0} & \texttt{0} & \texttt{r r r} & \texttt{0 0 0} & \texttt{r r r} & \texttt{1 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{STB - store byte}
Armazena um byte na memória. O endereço é obtido a partir do registrador base \textit{RsB}. O valor armazenado encontra-se na parte baixa do registrador fonte \textit{RsA}.

\begin{itemize}
\item STB r0, RsA, RsB
\subitem \texttt{MEM[GPR[RsB]] $\leftarrow$ GPR[RsA]\textsubscript{<7:0>}}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 0 0 1} & \texttt{0} & \texttt{0 0 0} & \texttt{r r r} & \texttt{r r r} & \texttt{1 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{LDW - load word}
Carrega uma palavra da memória. O endereço é obtido a partir do registrador base \textit{RsB} e deve estar alinhado ao tamanho da palavra (16 ou 32 bits). O valor é carregado no registrador destino \textit{Rst}.

\begin{itemize}
\item LDW Rst, r0, RsB
\subitem \texttt{GPR[Rst] $\leftarrow$ MEM[GPR[RsB]]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 0 0} & \texttt{0} & \texttt{r r r} & \texttt{0 0 0} & \texttt{r r r} & \texttt{1 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{STW - store word}
Armazena uma palavra na memória. O endereço é obtido a partir do registrador base \textit{RsB} e deve estar alinhado ao tamanho da palavra (16 ou 32 bits). O valor armazenado encontra-se no registrador fonte \textit{RsA}.

\begin{itemize}
\item STW r0, RsA, RsB
\subitem \texttt{MEM[GPR[RsB]] $\leftarrow$ GPR[RsA]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{0 1 0 1} & \texttt{0} & \texttt{0 0 0} & \texttt{r r r} & \texttt{r r r} & \texttt{1 0} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsection{Desvios condicionais}
\subsubsection{BEZ - branch if equal zero}
Realiza um desvio condicional, caso o valor de Fonte 1 seja zero. O endereço é obtido a partir do registrador base \textit{RsB} ou relativo ao PC e deve estar alinhado ao tamanho de uma instrução (16 bits).

\begin{itemize}
\item BEZ r0, RsA, RsB
\subitem \texttt{if (GPR[RsA] == zero) PC $\leftarrow$ GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{1 1 0 0} & \texttt{0} & \texttt{0 0 0} & \texttt{r r r} & \texttt{r r r} & \texttt{1 1} \\ \hline
\end{tabular}
\end{table}

\item BEZ Rst, Immediate
\subitem \texttt{if (GPR[Rst] == zero) PC $\leftarrow$ PC + SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{1 1 0 0} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

\subsubsection{BNZ - branch if not equal zero}
Realiza um desvio condicional, caso o valor de Fonte 1 não seja zero. O endereço é obtido a partir do registrador base \textit{RsB} ou relativo ao PC e deve estar alinhado ao tamanho de uma instrução (16 bits).

\begin{itemize}
\item BNZ r0, RsA, RsB
\subitem \texttt{if (GPR[RsA] != zero) PC $\leftarrow$ GPR[RsB]}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{1.6cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:5>}$ & $I_{<4:2>}$ & $I_{<1:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{RsA} & \textit{RsB} & \textit{Op2} \\ \hline
\texttt{1 1 0 1} & \texttt{0} & \texttt{0 0 0} & \texttt{r r r} & \texttt{r r r} & \texttt{1 1} \\ \hline
\end{tabular}
\end{table}

\item BNZ Rst, Immediate
\subitem \texttt{if (GPR[Rst] != zero) PC $\leftarrow$ PC + SEXT(Immediate)}
\begin{table}[ht!]
\centering
\begin{tabular}{|p{1.6cm}|p{1.6cm}|p{1.6cm}|p{5.65cm}|}
\hline
$I_{<15:12>}$ & $I_{<11>}$ & $I_{<10:8>}$ & $I_{<7:0>}$ \\ \hline
\textit{Opcode} & \textit{Imm} & \textit{Rst} & \textit{Immediate} \\ \hline
\texttt{1 1 0 1} & \texttt{1} & \texttt{r r r} & \texttt{i i i i i i i i} \\ \hline
\end{tabular}
\end{table}
\end{itemize}

A tabela a seguir apresenta um resumo das operações definidas na arquitetura. Importante observar que diversos \textit{opcodes} não foram definidos, o que permite adição de novas instruções ao conjunto básico. Além disso, alguns opcodes são reaproveitados para instruções semelhantes, como instruções que fazem ou não o uso do qualificador \textit{carry}.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.5cm}|p{5.6cm}|p{1.6cm}|p{1.1cm}|p{1.6cm}|}
\hline
\bf{Instrução} 					& \bf{Descrição} & \bf{Opcode} & \bf{Imm} & \bf{Op2} \\ \hline \hline
AND & Logical product 				& \texttt{0 0 0 0} & \texttt{x} & \texttt{x x} \\ \hline
OR & Logical sum 				& \texttt{0 0 0 1} & \texttt{x} & \texttt{x x} \\ \hline
XOR & Logical difference 			& \texttt{0 0 1 0} & \texttt{x} & \texttt{x x} \\ \hline
SLT & Set if less than 				& \texttt{0 0 1 1} & \texttt{x} & \texttt{x x} \\ \hline
SLTU & Set if less than (unsigned) 		& \texttt{0 1 0 0} & \texttt{x} & \texttt{x x} \\ \hline
ADD & Add 					& \texttt{0 1 0 1} & \texttt{x} & \texttt{x x} \\ \hline
ADC & Add with carry				& \texttt{0 1 0 1} & \texttt{0} & \texttt{0 1} \\ \hline
SUB & Subtract 					& \texttt{0 1 1 0} & \texttt{x} & \texttt{x x} \\ \hline
SBC & Subtract with carry			& \texttt{0 1 1 0} & \texttt{0} & \texttt{0 1} \\ \hline
LDR & Load register 				& \texttt{1 0 0 0} & \texttt{1} & \texttt{x x} \\ \hline
LDC & Load constant 				& \texttt{1 0 0 1} & \texttt{1} & \texttt{x x} \\ \hline
LSR & Logical shift right			& \texttt{1 0 1 0} & \texttt{0} & \texttt{0 0} \\ \hline
ASR & Arithmetic shift right			& \texttt{1 0 1 0} & \texttt{0} & \texttt{0 1} \\ \hline
ROR & Rotate right through carry			& \texttt{1 0 1 0} & \texttt{0} & \texttt{1 0} \\ \hline
LDB & Load byte 				& \texttt{0 0 0 0} & \texttt{0} & \texttt{1 0} \\ \hline
STB & Store byte 				& \texttt{0 0 0 1} & \texttt{0} & \texttt{1 0} \\ \hline
LDW & Load word 				& \texttt{0 1 0 0} & \texttt{0} & \texttt{1 0} \\ \hline
STW & Store word 				& \texttt{0 1 0 1} & \texttt{0} & \texttt{1 0} \\ \hline
BEZ & Branch if equal zero 			& \texttt{1 1 0 0} & \texttt{x} & \texttt{x x} \\ \hline
BNZ & Branch if not equal zero 			& \texttt{1 1 0 1} & \texttt{x} & \texttt{x x} \\ \hline
\end{tabular}
\end{table}

\section{Detalhes sobre a codificação de instruções}

As decisões abaixo foram tomadas durante o projeto do conjunto de instruções, com o principal objetivo de simplificar o projeto de hardware (incluindo a decodificação de instruções) e permitir a implementação de software eficiente. Em particular, o uso do qualificador \textit{carry} simplifica operações aritméticas e comparações que compreendem múltiplas palavras.

\begin{enumerate}
\item {As instruções mais comuns possuem tipos I e R, expandindo a funcionalidade do conjunto de instruções;
	\begin{itemize}
	\item AND, OR, XOR, SLT, SLTU, ADD, SUB, BEZ, BNZ - tipo R
	\item ANDI, ORI, XORI, SLTI, SLTUI, ADDI, SUBI, BEZI, BNZI - tipo I\footnote{A nomenclatura apresentada para essas instruções não existe no processador Viking, sendo seu tipo definido pelo formato da instrução. No entanto, o comportamento dessas instruções é semelhante a casos encontrados em outros processadores, como MIPS por exemplo.}
	\end{itemize}
}
\item {Algumas instruções possuem apenas um único modo de endereçamento;
	\begin{itemize}
	\item ADC, SBC, LSR, ASR, ROR, LDB, STB, LDW, STW - modo registrador
	\item LDR, LDC - modo imediato
	\end{itemize}
}
\item {Algumas instruções compartilham o mesmo \textit{Opcode}. Nesses casos, a desambiguação ocorre pelos campos \textit{Imm = } 0 e \textit{Op2 = } 00 para instruções mais comuns ou 01 para operações de computação com \textit{carry};
	\begin{itemize}
	\item ADD, ADDI, ADC - 0101
	\item SUB, SUBI, SBC - 0110
	\end{itemize}
}
\item Operações de deslocamento e rotação (LSR, ASR e ROR) são um caso especial, e compartilham o mesmo \textit{opcode}. A desambiguação é feita pelos campos \textit{Imm = } 0 e \textit{Op2} de acordo com a instrução;
\item Todas as operações de carga e armazenamento utilizam os campos \textit{Imm = } 0 e \textit{Op2 = }10. Quatro \textit{Opcodes} são reciclados;
\item Desvios são codificados com \textit{Opcode >=} 1100;
\item \textit{Opcodes} 0111, 1011, 1110 e 1111 estão disponíveis;
\item \textit{Opcodes} onde \textit{Imm = }0 e \textit{Op2 = } 11 estão disponíveis.
\end{enumerate}

\section{Características únicas}
\subsection{Carga de constantes}
\label{ref:constants}
A carga de constantes pode ser realizada com as instruções LDR e LDC. A instrução LDR simplifica a carga de constantes com valor entre $\pm$128 e outras com valor negativo e maior magnitude. O objetivo de existir uma instrução específica para carga de valores pequenos é o fato da maior parte das constantes terem um valor nessa faixa, além de inicializar com a extensão de sinal a parte alta de um registrador. O valor -1 pode ser carregado diretamente com:

\begin{verbatim}
        ldr r1,-1
\end{verbatim}

Para constantes com valores fora da faixa de valores entre $\pm$128 uma sequência de instruções LDC (ou LDR + LDC) pode ser usada. Uma constante em uma arquitetura de 16 bits pode ser carregada pela seguinte sequência. O valor a ser carregado é $1234_{16}$ e os bytes são carregados a partir do byte mais significativo\footnote{Mais detalhes sobre a ordem de bytes da arquitetura são apresentados na Seção \ref{ref:data_types}.}, sendo os valores especificados em decimal.

\begin{verbatim}
        ldc r1,18
        ldc r1,52
\end{verbatim}

Para a carga da mesma constante em uma arquitetura de 32 bits, a sequência a seguir pode ser utilizada.

\begin{verbatim}
        ldc r1,0
        ldc r1,0
        ldc r1,18
        ldc r1,52
\end{verbatim}

É importante observar que com a carga de todo o registrador qualquer informação antiga terá sido eliminada, uma vez que o registrador tem seu conteúdo deslocado à esquerda 8 bits a cada instrução. Uma maneira mais eficiente seria (desde que o valor do primeiro byte seja menor que 128):

\begin{verbatim}
        ldr r1,18
        ldc r1,52
\end{verbatim}

O valor -31073 pode ser carregado com o par de instruções a seguir (assumindo que a instrução LDR utiliza uma constante sinalizada e LDC não):

\begin{verbatim}
        ldr r1,-122
        ldc r1,159
\end{verbatim}

Outro exemplo seria a carga de constantes com valores de grande magnitude (32 bits). No exemplo, o valor a ser carregado é $12345678_{16}$ (ou $305419896_{10}$).

\begin{verbatim}
        ldc r1,0x12
        ldc r1,0x34
        ldc r1,0x56
        ldc r1,0x78
\end{verbatim}

Para o caso de uma arquitetura de 32 bits, de uma a quatro instruções podem ser utilizadas, sendo que o número de instruções varia de acordo com a magnitude do valor da constante. Para uma versão de 16 bits, duas instruções LDC podem ser utilizadas para a carga de constantes fora da faixa de valor $\pm$128.

\subsection{Extensão de sinal}
\label{ref:sign_ext}
Para que valores imediados (instruções do tipo I) possam ser utilizados para aritmética, é necessário que a sinalização adequada seja mantida (em complemento de dois). Para implementar a extensão de sinal, o valor do oitavo bit do campo imediato (bit 7) é replicado para todos os bits mais significativos de Fonte 2. O comportamento da extensão de sinal pode ser descrito como \texttt{SEXT(Immediate) $\leftarrow$ Immediate\textsubscript{<7>} ... Immediate\textsubscript{<7:0>}}. As únicas operações do tipo I que não utilizam extensão de sinal, ou seja utilizam extensão por zero, são as instruções AND, OR e LDC.

\subsection{Desvios condicionais}
São definidas duas instruções de desvios condicionais (BEZ e BNZ) na arquitetura, que comparam o valor de um registrador com zero e realizam desvios condicionalmente. O motivo para a definição dessas instruções, e não instruções mais genéricas que comparam o valor de um registrador com qualquer valor (como BEQ e BNE) é simples. No tipo de instrução R, três registradores são referenciados. Se dois valores a serem comparados estivessem em registrador, e mais um registrador de endereços fosse referenciado na mesma instrução, seriam necessárias três portas de leitura no banco de registradores. Além disso, seria necessário o uso de um multiplexador adicional para modificar a semântica dos campos \textit{Rst}, \textit{RsA} e \textit{RsB} em instruções de desvio.

%\subsection{Soma e subtração com \textit{carry}}
\subsection{Soma e subtração de múltipla precisão}
A arquitetura define modificadores para as operações de soma (ADD) e subtração (SUB) para a inclusão de um valor de \textit{carry} gerado pela última operação aritmética. Tais operações são definidas pelas instruções ADC (\textit{Add with carry}) e SBC (\textit{Subtract with carry}), e podem ser utilizadas para simplificar o cálculo de valores de maior magnitude que o suportado pela largura natural da arquitetura. Por exemplo, supondo que deseja-se realizar uma soma em uma arquitetura de 16 bits, onde dois valores de 32 bits estão dispostos em quatro registradores (no exemplo, o primeiro operando está armazenado em \textit{r1:r0} (parte alta e baixa, respectivamente) e o segundo operando está em \textit{r3:r2}). A operação pode ser realizada da seguinte forma:

\begin{verbatim}
        add r2,r2,r0
        adc r3,r3,r1
\end{verbatim}

Na primeira instrução, as partes baixas são somadas e o resultado é armazenado em \textit{r2}, gerando-se também o \textit{carry}. Na segunda instrução, as partes altas são somadas, juntamente com o valor do \textit{carry} da última operação e o resultado é armazenado em \textit{r3}.

É importante observar que todas as instruções da arquitetura modificam o estado do qualificador \textit{carry} mas apenas as instruções de soma (ADD, ADC), subtração (SUB, SBC) e deslocamento ou rotação (LSR, ASR, ROR) fazem uso do qualificador (gerado pela última instrução) e podem definir seu valor em 1, caso ocorra \textit{carry}. Em todos os outros casos, \textit{carry} possui o valor 0 após a execução da instrução.

%\subsection{Deslocamento com \textit{carry}}
\subsection{Deslocamento de múltipla precisão}

São definidas três operações de deslocamento na arquitetura, incluindo o deslocamento lógico à direita (LSR), deslocamento aritmético à direita (ASR) e rotação à direita (ROR). Em todos os casos, o bit deslocado define o valor do qualificador \textit{carry} após a execução da instrução. A instrução de rotação utiliza o valor de \textit{carry} gerado na última instrução como o valor incluído em seu bit mais significativo, e modifica o valor de \textit{carry} com o valor do bit deslocado (perdido). A instrução de rotação (juntamente com as instruções de deslocamento) pode ser utilizada para a manipulação de valores maiores que o naturalmente suportado pela arquitetura. Por exemplo, supondo que a arquitetura seja de 16 bits e um valor de 32 bits esteja disposto em dois registradores (\textit{r2:r1}), a operação de deslocamento em 32 bits pode ser realizada da seguinte forma (essencialmente, dividindo o valor de 32 bits por 2 e mantendo o valor sinalizado):

\begin{verbatim}
        asr r2,r2
        ror r1,r1
\end{verbatim}

As operações de deslocamento e rotação à esquerda são sintetizadas com o uso das instruções ADD e ADC, respectivamente. Seguindo o exemplo anterior, poderia-se realizar a mesma operação, porém com o deslocamento à esquerda, da seguinte forma (essencialmente, multiplicando o valor de 32 bits por 2):

\begin{verbatim}
        add r1,r1
        adc r2,r2
\end{verbatim}

%\subsection{Comparações com \textit{carry}}
\subsection{Comparações de múltipla precisão}

Operações de comparação também podem utilizar \textit{carry} com o objetivo de permitir de maneira simplificada a avaliação entre operandos maiores que a largura natural da arquitetura. Uma instrução semelhante a \textit{Set if less than (unsigned)} pode ser sintetizada pelo seguinte código (operandos de 32 bits):

\begin{verbatim}
        xor r0,r0,r0
        sub r3,r3,r1
        sbc r4,r4,r2
        adc r1,r0,r0
\end{verbatim}

No exemplo apresentado, se o resultado contido nos registradores \textit{r4:r3} for menor que \textit{r2:r1} (sem sinal), o valor 1 será armazenado em \textit{r1} e 0 caso contrário.
%Para uma versão que envolve operandos sinalizados em complemento de 2, é necessário apenas inverter o sinal dos dois operandos (bit mais significativo) e realizar o teste como se os números não fossem sinalizados:
Uma versão que envolve o uso de operandos sinalizados (em complemento de 2) é apresentada abaixo:

%\begin{verbatim}
%        ldr r0,0x80
%        ldc r0,0x00
%        xor r2,r2,r0
%        xor r4,r4,r0
%        xor r0,r0,r0
%        sub r1,r1,r3
%        sbc r2,r2,r4
%        adc r1,r0,r0
%\end{verbatim}
\begin{verbatim}
        sltu r4,r2,r4
        sub r2,r1,r3
        sltu r2,1
        and r4,r4,r2
        sltu r1,r1,r3
        or r1,r1,r4        
\end{verbatim}

Em ambos os casos não são necessários desvios\footnote{Em arquiteturas RISC, muitas vezes não existem qualificadores de operação (como o \textit{carry}), o que complica consideravelmemente a implementação de operações que envolvem precisão maior em função de desvios condicionais. O uso de desvios, além de aumentar o tamanho do código, implica em degradação da execução em função de sua influência no \textit{pipeline} de execução.} adicionais (além do desvio posterior ao teste, não mostrado nos exemplos) para a implementação das comparações em comandos de seleção e repetição.

\subsection{Outras operações}
Algumas operações elementares como complemento, deslocamentos à esquerda e outros tipos de desvios são implementados na arquitetura com o uso de pseudo operações. Em algumas operações, não existe vantagem alguma em incluir \textit{hardware} adicional para o seu suporte, uma vez que as mesmas podem ser sintetizadas diretamente por outras equivalentes. Um exemplo é o deslocamento à esquerda, que pode ser obtido somando-se um valor a ele mesmo, não sendo necessária uma instrução separada para implementar esse comportamento.

Outras operações podem ser sintetizadas com sequências de poucas instruções elementares. Mais detalhes sobre tais operações são apresentados no Capítulo \ref{ref:pseudo_ops}.

\section{Tipos de dados}
\label{ref:data_types}
Viking é uma arquitetura \textit{big-endian}, ou seja, tipos compostos por múltiplos bytes possuem o endereço alinhado com o byte mais significativo. Dessa forma, o primeiro byte de uma instrução (mais significativo) é capaz de conter informação suficiente para definir operações que resultem em instruções com tamanho maior que 16 bits, uma possível extensão do formato de instruções. Na arquitetura Viking existem dois tipos de dados:

\begin{itemize}
\item Um \textit{byte} possui 8 bits. Em operações de carga e armazenamento o byte mais significativo de uma palavra (dados, bits <31:24> para 32 bits ou bits <15:8> para 16 bits) é acessado quando o endereço estiver alinhado (endereço, bits <1:0> = 0 para 32 bits ou bit <0> = 0 para 16 bits) e o byte menos significativo é acessado quando os bits do endereço forem <1:0> = 3 (para palavras de 32 bits) e <0> = 1 (para palavras de 16 bits).
\item Uma \textit{palavra} possui 32 ou 16 bits (dependendo da implementação). Esse tipo possui seu byte mais significativo acessado na parte alta da palavra em operações de carga e armazenamento quando o endereço estiver alinhado (bits <1:0> = 0 para 32 bits ou bit <0> = 0 para 16 bits). Não são definidos acessos desalinhados para esse tipo.
\end{itemize}

\chapter{Síntese de pseudo operações}
\label{ref:pseudo_ops}

Neste Capítulo são apresentadas diversas instruções que não fazem parte da arquitetura Viking, mas que podem ser sintetizadas de maneira simples. As operações apresentadas correspondem a instruções tipicamente encontradas em arquiteturas RISC, e servem para facilitar o desenvolvimento de programas em linguagem de montagem ou para a simplificação das listagens resultantes do processo de compilação.

Nas tabelas de instruções são apresentados o formato da instrução (pseudo operação) e a sua equivalência em uma sequência de instruções suportadas pela arquitetura. Em instruções que necessitam de um registrador temporário, \textit{at} é utilizado para esse fim. O registrador \textit{lr} é utilizado como endereço de retorno.

\section{Pseudo operações básicas}

Instruções de complemento são sintetizadas com operações XOR e ADD. Deslocamentos e rotações à esquerda são sintetizados com operações ADD e ADC. A carga de constantes é sintetizada de maneira trivial pelo montador, no entanto uma sequência mais otimizada pode ser gerada, como apresentado na Seção \ref{ref:constants}. O parâmetro \textit{const} da pseudo operação LDI pode ser tanto um valor numérico quanto um rótulo, tendo seu valor resolvido pelo montador.

Operações de carga e armazenamento e desvios podem ser especificadas com apenas dois registradores, uma vez que para essas instruções um dos registradores não é utilizado fazendo com que o formato com três registradores se torne pouco intuitivo. Os parâmetros \textit{addr} das operações BEZ e BNZ podem ser rótulos, sendo que essas operações fazem uso do registrador \textit{at} para a carga do endereço. Isso simplifica o código de montagem pois o programador não precisa carregar o endereço manualmente. Outras operações que fazem uso de rótulos são LDB, STB, LDW e STW. A operação HCF não é definida pela arquitetura, e possui funcionalidade apenas no contexto de simulação (a simulação é abortada).

Nos formatos de pseudo operações suportadas pelo montador, o registrador \textit{r1} é exemplificado como registrador destino ou fonte da operação, enquanto \textit{r2} é fonte. Em casos onde o endereço necessita ser calculado em função de um rótulo, \textit{at} é fonte.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 				& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
NOP  & No operation 			& \texttt{nop} & \texttt{and r0,r0,r0}  \\ \hline
NOT  & One's complement 		& \texttt{not r1} & \texttt{xor r1,-1}  \\ \hline
NEG  & Two's complement			& \texttt{neg r1} & \texttt{xor r1,-1\newline add r1,1} \\ \hline
MOV  & Move register			& \texttt{mov r1,r2} & \texttt{and r1,r2,r2} \\ \hline
LSR  & Logical shift right		& \texttt{lsr r1,r2} & \texttt{lsr r1,r2,r0} \\ \hline
ASR  & Arithmetic shift right		& \texttt{asr r1,r2} & \texttt{asr r1,r2,r0} \\ \hline
ROR  & Rotate right through carry	& \texttt{ror r1,r2} & \texttt{ror r1,r2,r0} \\ \hline
LSL  & Logical shift left		& \texttt{lsl r1,r2} & \texttt{add r1,r2,r2} \\ \hline
ROL  & Rotate left through carry		& \texttt{rol r1,r2} & \texttt{adc r1,r2,r2} \\ \hline
LDI  & Load immediate			& \texttt{ldi r1,\textit{const}} & \texttt{ldr r1,\textit{byte0}\newline ldc r1,\textit{byte1}\newline ...} \\ \hline
BEZ  & Branch if equal zero		& \texttt{bez r1,r2} & \texttt{bez r0,r1,r2} \\ \hline
	& 				& \texttt{bez r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline bez r0,r1,at} \\ \hline
BNZ  & Branch if not equal zero		& \texttt{bnz r1,r2} & \texttt{bnz r0,r1,r2} \\ \hline
	& 				& \texttt{bnz r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline bnz r0,r1,at} \\ \hline
LDB  & Load byte			& \texttt{ldb r1,r2} & \texttt{ldb r1,r0,r2} \\ \hline
	& 				& \texttt{ldb r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline ldb r1,r0,at} \\ \hline
STB  & Store byte			& \texttt{stb r1,r2} & \texttt{stb r0,r1,r2} \\ \hline
	& 				& \texttt{stb r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline stb r0,r1,at} \\ \hline
LDW  & Load word			& \texttt{ldw r1,r2} & \texttt{ldw r1,r0,r2} \\ \hline
	& 				& \texttt{ldw r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline ldw r1,r0,at} \\ \hline
STW  & Store word			& \texttt{stw r1,r2} & \texttt{stw r0,r1,r2} \\ \hline
	&				& \texttt{stw r1,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline stw r0,r1,at} \\ \hline
HCF  & Halt and catch fire		& \texttt{hcf} & \texttt{0x0003} (padrão)  \\ \hline
\end{tabular}
\end{table}

\section{Operações de deslocamento}

Nas operações de deslocamento que envolvem múltiplos bits o registrador \textit{r1} é exemplificado como fonte e destino e \textit{r2} contém o número de bits a serem deslocados. O conteúdo de \textit{r2} também é modificado como resultado do processamento.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 					& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
LSRM & Logical shift right multiple		& \texttt{lsrm r1,r2} & \texttt{bez r2,6\newline lsr r1,r1,r0\newline sub r2,1\newline bnz r2,-6} \\ \hline
ASRM & Arithmetic shift right multiple		& \texttt{asrm r1,r2} & \texttt{bez r2,6\newline asr r1,r1,r0\newline sub r2,1\newline bnz r2,-6} \\ \hline
LSLM & Logical shift left multiple		& \texttt{lslm r1,r2} & \texttt{bez r2,6\newline add r1,r1,r1\newline sub r2,1\newline bnz r2,-6} \\ \hline
\end{tabular}
\end{table}

\section{Pseudo operações não suportadas pelo montador}

\subsection{Testes, seleção e desvios (condicionais)}
Em pseudo operações que envolvem testes, os registradores \textit{r2} e \textit{r3} são exemplificados como operandos e \textit{r1} como alvo. As operações SLT e SLTU já fazem parte do conjunto de instruções básico, e por isso não foram apresentadas na tabela.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 					& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
SEQ  & Set if equal 				& \texttt{seq r1,r2,r3} & \texttt{sub r1,r2,r3\newline sltu r1,1} \\ \hline
SNE  & Set if not equal				& \texttt{sne r1,r2,r3} & \texttt{sub r1,r2,r3\newline sltu r1,1\newline xor r1,1} \\ \hline
SGE  & Set if greater equal			& \texttt{sge r1,r2,r3} & \texttt{slt r1,r2,r3\newline xor r1,1} \\ \hline
SGEU & Set if greater equal (unsigned)		& \texttt{sgeu r1,r2,r3} & \texttt{sltu r1,r2,r3\newline xor r1,1} \\ \hline
\end{tabular}
\end{table}

Nos formatos de desvios condicionais, os registradores \textit{r1} e \textit{r2} são exemplificados como operandos, sendo o valor de \textit{r1} não preservado. Um endereço é definido no rótulo \textit{addr}.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 					& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
BEQ  & Branch if equal 				& \texttt{beq r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline sub r1,r1,r2\newline bez r0,r1,at} \\ \hline
BNE  & Branch if not equal			& \texttt{bne r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline sub r1,r1,r2\newline bnz r0,r1,at} \\ \hline
BLT  & Branch if less than			& \texttt{blt r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline slt r1,r1,r2\newline bnz r0,r1,at} \\ \hline
BGE  & Branch if greater equal			& \texttt{bge r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline slt r1,r1,r2\newline bez r0,r1,at} \\ \hline
BLTU & Branch if less than (unsigned)		& \texttt{bltu r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline sltu r1,r1,r2\newline bnz r0,r1,at} \\ \hline
BGEU & Branch if greater equal (unsigned)	& \texttt{bgeu r1,r2,\textit{addr}} & \texttt{ldi at,\textit{addr}\newline sltu r1,r1,r2\newline bez r0,r1,at} \\ \hline
\end{tabular}
\end{table}

\subsection{Operações condicionais equivalentes}

Outras operações condicionais são equivalentes às definidas anteriormente, sendo apenas necessário inverter a ordem dos operandos. Por exemplo, a instrução BLE é a mesma que BGE porém com os operandos invertidos.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 					& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
SGT  & Set if greater equal			& \texttt{sgt r1,r2,r3} & \texttt{slt r1,r3,r2} \\ \hline
SLE  & Set if less equal			& \texttt{sle r1,r2,r3} & \texttt{sge r1,r3,r2} \\ \hline
SGTU & Set if greater than (unsigned)		& \texttt{sgtu r1,r2,r3} & \texttt{sltu r1,r3,r2} \\ \hline
SLEU & Set if less equal (unsigned)		& \texttt{sleu r1,r2,r3} & \texttt{sgeu r1,r3,r2} \\ \hline
BGT  & Branch if greater than			& \texttt{bgt r1,r2,r3} & \texttt{blt r2,r1,r3} \\ \hline
BLE  & Branch if less equal			& \texttt{ble r1,r2,r3} & \texttt{bge r2,r1,r3} \\ \hline
BGTU & Branch if greater than (unsigned)	& \texttt{bgtu r1,r2,r3} & \texttt{bltu r2,r1,r3} \\ \hline
BLEU & Branch if less equal (unsigned)		& \texttt{bleu r1,r2,r3} & \texttt{bgeu r2,r1,r3} \\ \hline
\end{tabular}
\end{table}

\subsection{Desvios incondicionais}

Desvios incondicionais, assim como operações de chamada e retorno de subrotina podem ser trivialmente emuladas. Assume-se que \textit{r7} (\textit{sp}) seja sempre diferente de zero.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 				& \bf{Descrição} & \bf{Formato} & \bf{Equivalência} \\ \hline \hline
JMP  & Jump				& \texttt{jmp \textit{addr}} & \texttt{ldi at,\textit{addr}\newline bnz r0,r7,at} \\ \hline
JAL  & Jump and link			& \texttt{jal \textit{addr}} & \texttt{ldi at,\textit{addr}\newline ldi lr,\textit{raddr}\newline bnz r0,r7,at} \\ \hline
JMPR & Jump register 			& \texttt{jmpr r1} & \texttt{bnz r0,r7,r1} \\ \hline
JALR & Jump and link register		& \texttt{jalr r1} & \texttt{ldi lr,\textit{raddr}\newline bnz r0,r7,r1} \\ \hline
RET  & Return				& \texttt{ret} & \texttt{bnz r0,r7,lr}\\ \hline
\end{tabular}
\end{table}

\subsection{Operações aritméticas adicionais}

Para operações de multiplicação, divisão e resto são necessárias chamadas para funções que emulam tais instruções. Nessas operações, os registradores \textit{r2} e \textit{r3} são exemplificados como operandos e \textit{r1} como alvo. As rotinas \textit{mulsi3} (multiplicação), \textit{divsi3} (divisão) e \textit{modsi3} (resto) são apresentadas no Apêndice \ref{ref:muldiv}.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.0cm}|p{4.0cm}|p{3.5cm}|p{3.5cm}|}
\hline
\bf{Instrução} 				& \bf{Descrição} & \bf{Formato / \textit{oper}} & \bf{Equivalência} \\ \hline \hline
MUL / DIV / REM & Multiply / Divide / Division remainder				& \texttt{mul r1,r2,r3 (\textit{mulsi3}) / div r1,r2,r3 (\textit{divsi3}) / rem r1,r2,r3 (\textit{modsi3})} & \texttt{sub sp,2\newline stw r0,r2,sp\newline   sub sp,2\newline stw r0,r3,sp\newline sub sp,2\newline stw r0,lr,sp\newline ldi lr,\textit{raddr}\newline ldi sr,\textit{oper}\newline bnz r0,r7,sr\newline \textit{raddr}\newline ldw lr,r0,sp\newline add sp,6\newline and r1,sr,sr} \\ \hline
\end{tabular}
\end{table}

\chapter{Programando com o processador Viking}

Algumas estruturas de controle básicas para a programação do processador são apresentadas nas próximas seções. Nos exemplos apresentados serão usadas apenas instruções suportadas nativamente pela arquitetura e pseudo operações básicas suportadas pelo montador, com o objetivo de ilustrar padrões simples para construção de código.

\section{Controle de fluxo do programa}

As estruturas de controle básicas de linguagem de alto nível como seleção e repetição podem ser implementadas para o controle de fluxo de execução com apenas quatro instruções (SUB, SLT, BNZ e BEZ) na arquitetura Viking.

\subsection{Seleção}

\subsubsection{Igual a (==) e diferente de (!=)}

Em um comando de seleção que utiliza uma comparação por igualdade (\textit{if (a == b)}), são utilizadas instruções SUB e BEZ. A idéia é que se dois valores forem iguais (nesse caso, as variáveis \textit{a} e \textit{b} estão armazenadas nos registradores \textit{r1} e \textit{r2} respectivamente) a subtração de ambos resultará em zero, e o desvio do fluxo de controle (condicional) será executado (\textit{if}).

\begin{verbatim}
    sub r3,r1,r2
    bez r3,if
else
    ...
if
    ...
\end{verbatim}

Quando a comparação for por não igualdade (\textit{if (a != b)}), utiliza-se uma instrução BNZ. Neste caso, sempre que o resultado da subtração for diferente de zero (ou seja, se os valores de \textit{a} e \textit{b} forem diferentes) o desvio será executado.

\begin{verbatim}
    sub r3,r1,r2
    bnz r3,if
else
    ...
if
    ...
\end{verbatim}

\subsubsection{Menor que (<) e maior ou igual a (>=)}

Para a implementação de seleção para uma comparação por menor que (\textit{if (a < b)}) as instruções SLT (ou SLTU, caso os valores a serem comparados não forem sinalizados) e BNZ são utilizadas. Se o valor de \textit{r1} for menor que \textit{r2}, o resultado da comparação será diferente de zero, e o salto será executado.

\begin{verbatim}
    slt r3,r1,r2
    bnz r3,if
else
    ...
if
    ...
\end{verbatim}

Em uma comparação por maior ou igual a (\textit{if (a >= b)}) a lógica é a mesma, porém utiliza-se uma instrução BEZ. Deve-se lembrar que se um número não for menor que outro (<) ele é maior ou igual ao outro número (>=), então a única diferença entre as duas comparações deve ser a instrução de salto.

\begin{verbatim}
    slt r3,r1,r2
    bez r3,if
else
    ...
if
    ...
\end{verbatim}

\subsubsection{Maior que (>) e menor ou igual a (<=)}

Para a implementação de seleção para uma comparação por maior que (\textit{if (a > b)}) as instruções SLT (ou SLTU, caso os valores a serem comparados não forem sinalizados) e BNZ são utilizadas. Se o valor de \textit{r2} for menor que \textit{r1}, (ou seja, \textit{r1} for maior que \textit{r2}) o resultado da comparação será diferente de zero, e o salto será executado.

\begin{verbatim}
    slt r3,r2,r1
    bnz r3,if
else
    ...
if
    ...
\end{verbatim}

Em uma comparação por menor ou igual a (\textit{if (a <= b)}) a lógica é a mesma, porém utiliza-se uma instrução BEZ. Deve-se lembrar que se um número não for maior que outro (>) ele é menor ou igual ao outro número (<=), então a única diferença entre as duas comparações deve ser a instrução de salto.

\begin{verbatim}
    slt r3,r2,r1
    bez r3,if
else
    ...
if
    ...
\end{verbatim}

\subsubsection{Alternativas para menor ou igual a (<=) e maior ou igual a (>=)}

Versões alternativas para as operações de seleção maior ou igual a (>=) e menor ou igual a (<=) podem ser usadas. Essas versões utilizam mais instruções, porém são mais simples de serem verificadas mentalmente. Nessas versões, os testes são realizados de forma independente - primeiramente o teste por menor que (<) é realizado (usando-se SLT e BNZ) pois cobre a maior parte dos casos, e posteriormente o teste por igualdade (==) é realizado (usando-se SUB e BEZ). A idéia é que qualquer uma das condições possa fazer com que o fluxo de execução seja desviado.

O exemplo abaixo realiza o teste para menor ou igual a (\textit{if (a <= b)}). Para o teste de maior ou igual a (\textit{if (a >= b)}, basta inverter a ordem de \textit{r1} e \textit{r2} na primeira instrução (SLT).

\begin{verbatim}
    slt r3,r1,r2
    bnz r3,if
    sub r3,r1,r2
    bez r3,if
else
    ...
if
    ...
\end{verbatim}

\subsection{Repetição}

Estruturas de controle de repetição em linguagem de montagem possuem uma estrutura semelhante à estruturas de seleção, com a diferença de que normalmente o fluxo de execução será redirecionado a um ponto do código percorrido anteriormente de maneira iterativa. Além da operação de repetição (como um \textit{for}, \textit{while} ou \textit{do .. while}), muitas vezes são utilizadas comandos do tipo \textit{break} (que quebra o laço incondicionalmente) e \textit{continue} (que desvia incondicionalmente para a próxima iteração do laço). Em todos os casos, são utilizadas estruturas semelhantes às apresentadas anteriormente.

\subsubsection{Repetição incondicional}

Um comando simples de repetição incondicional pode ser implementado de acordo com o padrão a seguir. Nesse exemplo, assume-se que o registrador \textit{r7} (ou \textit{sp}) nunca tenha um valor zero. Esse exemplo ilustra uma construção semelhante ao um laço \textit{while (1) \{ ... \}}.

\begin{verbatim}
while
    ...
    bnz r7,while
endwhile
\end{verbatim}

\subsubsection{Repetição condicional}

A implementação de um comando de repetição semelhante a \textit{while (a < b) \{ ... \}} é mostrado a seguir. Nesse exemplo, as variáveis \textit{a} e \textit{b} estão armazenadas nos registradores \textit{r1} e \textit{r2} respectivamente.

\begin{verbatim}
while
    slt r3,r1,r2
    bez r3,endwhile
    ...
    bnz r7,while
endwhile
\end{verbatim}

Importante observar no exemplo anterior que se a comparação \textit{a < b} for falsa (ou seja, zero), o fluxo de execução será desviado para o final do laço. Enquanto \textit{a < b}, o primeiro desvio não será tomado, o corpo da repetição será executado e o último comando de desvio (incondicional) irá desviar o fluxo de execução para o início do laço.

Para a implementação de um comando de repetição do tipo \textit{do { ... } while (a < b)} basta que o teste seja realizado no final do laço. Nesse exemplo, se a comparação \textit{a < b} for verdadeira, o fluxo de execução será desviado para o início do laço.

\begin{verbatim}
while
    ...
    slt r3,r1,r2
    bnz r3,while
endwhile
\end{verbatim}

\section{Acesso à memória - variáveis}

Apenas um número limitado de registradores está presente na arquitetura Viking. Parte desses registradores são usados para fins específicos (como apresentado na Seção \ref{ref:regs}), restando na maior parte dos casos apenas os registradores \textit{r1} a \textit{r5} como temporários para o armazenamento de variáveis.

A arquitetura realiza o acesso à memória de dados apenas com instruções carga e armazenamento (\textit{load / store}). Dessa forma, os operandos precisam serem trazidos da memória, uma vez que as operações lógicas e aritméticas são realizadas apenas nos registradores internos. Por exemplo, para realizar uma operação de soma entre duas variáveis e armazenar o resultado em uma terceira variável (C = A + B), é necessário um padrão semelhante ao apresentado abaixo, que realiza 3 acessos à memória de dados.

\begin{verbatim}
    ldw r1,A
    ldw r2,B
    add r3,r1,r2
    stw r3,C
    ...
A   123
B   333
C   0
\end{verbatim}

Caso uma variável seja utilizada frequentemente (um contador em um laço, por exemplo), pode-se fixar temporariamente o uso de um dos registradores para evitar operações de acesso à memória indesejáveis (carga da variável contador, incremento do contador e armazenamento da variável contador).

\section{Acesso à memória - vetores}

O acesso à vetores pode ser realizado com o uso de ponteiros. Um ponteiro nada mais é que uma variável (valor inteiro) que armazena um endereço de memória. Dessa forma, o ponteiro é utilizado para referenciar uma posição de memória. Esse endereço pode ser qualquer posição na memória, então um ponteiro pode referenciar o conteúdo de uma variável, ou elemento de um vetor.

Um detalhe importante para acesso à memória utilizando o conceito de ponteiros é que é necessário que o tipo de dados apontado seja conhecido. Por exemplo, na arquitetura Viking inteiros possuem 2 ou 4 bytes (2 em uma arquitetura de 16 bits, como no exemplo abaixo) e vetores de caracteres (\textit{strings}) possuem 1 byte por elemento. Precisamos levar isso em conta para calcular o deslocamento na memória durante o acesso à vetores.

Para o cálculo do deslocamento, usa-se a fórmula $d = i * ts$, onde $d$ é o deslocamento, $i$ é o índice do vetor e $ts$ é o tamanho do tipo de dado armazenado no vetor. Sabendo-se o deslocamento, é possível encontrar o endereço de memória efetivo de um determinado elemento em um índice $i$ de um vetor. Esse elemento $i$ pode ser acessado por um ponteiro que contém o endereço do primeiro elemento do vetor somado ao deslocamento (formando um endereço efetivo).

No exemplo abaixo, o quarto elemento de um vetor será acessado e nele armazenado o valor 123 (\textit{vetor[3] = 123}. Assume-se que \textit{vetor} possui 5 elementos do tipo inteiro de 16 bits.

\begin{verbatim}
    ldi r4,vet
    add r4,3
    add r4,3
    ldi r3,123
    stw r3,r4
    ...
vet 0 0 0 0 0
\end{verbatim}

No código acima, o endereço do primeiro elemento do vetor é carregado em \textit{r4} com a instrução LDI. O endereço efetivo é calculado somando-se o índice (nesse caso 3) duas vezes (ou seja, 3 multiplicado por 2 em função do tipo inteiro) ao endereço inicial. O acesso ao vetor é realizado pela instrução STW, que armazena o valor de \textit{r3} no endereço efetivo armazenado em \textit{r4}.

Para se realizar o acesso à um vetor de caracteres, o índice não precisa ser multiplicado pelo tamanho do tipo. Além disso usam-se instruções LDB e STB para a leitura e escrita. No exemplo abaixo o elemento \textit{vet[10]} (um espaço em branco) é substituído por uma quebra de linha ('$\backslash n$').

\begin{verbatim}
    ldi r4,vet
    add r4,10
    ldi r3,0xa
    stb r3,r4
    ...
vet "fight fire with fire"
\end{verbatim}

\section{Chamadas de função e convenções de chamada}
\label{ref:fcalls_conv}

\subsection{Pilha}
\label{ref:stack}
Não há mecanismos ou instruções específicas para o gerenciamento da pilha. O programador é responsável por fazer a gerência manualmente, utilizando o registrador \textit{r7} (\textit{sp}) para essa finalidade. Por convenção, a pilha cresce do endereço mais alto para o endereço mais baixo, e esta deve ser inicializada com o endereço do topo da pilha no início do programa. Para implementar o comportamento de instruções estilo \textit{PUSH} e \textit{POP}, pode ser usado o seguinte padrão de código:

\begin{verbatim}
    sub sp,2          # PUSH r1
    stw r1,sp
    ...
    ldw r1,sp         # POP r1
    add sp,2
\end{verbatim}

Importante observar que no código foi considerada uma implementação de 16 bits da arquitetura. Caso fossem utilizados registradores de 32 bits, seria necessário alocar / desalocar 4 bytes na pilha, e não 2 como apresentado no exemplo.

\subsection{Registradores}
\label{ref:regs}
Um conjunto de 8 registradores de propósito geral é definido na arquitetura. Por questões de interoperabilidade, as seguintes convenções são definidas para o uso de tais registradores. Importante observar que os nomes alternativos podem ser utilizados para designar os papéis de registradores específicos e tornar o código de montagem mais legível.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{2.5cm}|p{1.6cm}|p{1.6cm}|p{4.3cm}|p{2.5cm}|}
\hline
\bf{Registrador} & \bf{Nome} & \bf{Apelido} & \bf{Papel} & \bf{Preservado} \\ \hline \hline
\texttt{0}	& \texttt{r0}	& \texttt{at}	& Temporário (montador) & Não \\ \hline
\texttt{1}	& \texttt{r1}	& \texttt{r1}	& Variável local & Chamado \\ \hline
\texttt{2}	& \texttt{r2}	& \texttt{r2}	& Variável local & Chamado \\ \hline
\texttt{3}	& \texttt{r3}	& \texttt{r3}	& Variável local & Chamado \\ \hline
\texttt{4}	& \texttt{r4}	& \texttt{r4}	& Variável local & Chamado \\ \hline
\texttt{5}	& \texttt{r5}	& \texttt{sr}	& Temporário & Não \\ \hline
\texttt{6}	& \texttt{r6}	& \texttt{lr}	& Endereço de retorno & Chamador \\ \hline
\texttt{7}	& \texttt{r7}	& \texttt{sp}	& Ponteiro de pilha & Sim \\ \hline
\end{tabular}
\end{table}

Nos formatos de instruções em que um dos registradores especificado é fixo, deve-se utilizar a notação \textit{r0}. Pseudo operações podem ser usadas nesse caso para que a referência a \textit{r0} seja omitida, uma vez que essa referência trata-se de um detalhe da arquitetura que não precisa ser exposto ao programador. Nos outros casos, o registrador 0 deve ser referenciado por \textit{at}. O registrador \textit{at} é reservado para a síntese de pseudo operações, e deve ser utilizado diretamente pelo programador apenas em situações em que não estão envolvidas pseudo operações. Os registradores \textit{r1} a \textit{r4} são de propósito geral e podem ser utilizados para avaliação de expressões e passagem de parâmetros. O registrador \textit{sr} é um registrador temporário, e pode ser utilizado para qualquer finalidade. Para chamada de procedimentos e manipulação da pilha são utilizados os registradores \textit{lr} e \textit{sp} respectivamente.

Caso necessário, os registradores \textit{sr} e \textit{lr} podem ser utilizados como registradores de propósito geral. Para que o registrador \textit{lr} possa ser utilizado com esse fim, seu conteúdo deve ser colocado na pilha no início da função, e restaurado no final antes de efetuado o retorno de função. Quando tratados como registradores de propósito geral, \textit{sr} e \textit{lr} devem ser referenciados por seus nomes \textit{r5} e \textit{r6}, ficando assim os registradores \textit{r1} a \textit{r6} (6 registradores) disponíveis para uso geral.

\subsection{Chamada e retorno de funções}
\label{ref:fcalls}
Em função do número reduzido de registradores na arquitetura, a passagem de parâmetros ocorre normalmente pela pilha. Apenas em casos onde não é desejável a manipulação da pilha (pequenas funções, por exemplo) os registradores \textit{r1} a \textit{r4} podem ser utilizados para essa finalidade. Nesse caso, é responsabilidade tanto da função chamadora quanto da função chamada definirem o protocolo adequado.

Não existem instruções nativas para o suporte de chamada e retorno de funções. Assim, para realizar a passagem de parâmetros pela pilha são necessárias as seguintes convenções:

\begin{itemize}
\item Usar o registrador \textit{r5} (\textit{scratch register, sr}) para o retorno de valores em funções. Se mais valores de retorno forem necessários, deve-se utilizar a pilha;
\item Usar o registrador \textit{r6} (\textit{link register, lr}) como um registrador de endereço de retorno, e gerenciar o mesmo usando a pilha no caso de chamadas recursivas;
\item Usar o registrador \textit{r7} (\textit{stack pointer, sp}) como ponteiro de pilha e fazer a sua gerência manualmente.
\end{itemize}

Uma chamada de função envolve gerenciar a passagem e retorno de parâmetros e endereços de chamada e retorno de função. Considerando as limitações da arquitetura, o seguinte protocolo pode ser usado:

\begin{enumerate}
\item Colocar os parâmetros na pilha (em ordem inversa);
\item Salvar \textit{lr} na pilha;
\item Carregar \textit{lr} com o endereço de retorno (um rótulo definido após a instrução de desvio que salta para a função chamada);
\item Carregar \textit{sr} com o endereço da função a ser chamada;
\item Saltar para \textit{sr} (chamada de função). Na função:
	\begin{enumerate}
	\item Salvar \textit{r1} até \textit{r4} na pilha, se necessário;
	\item (Fazer o que for necessário);
	\item Escrever o resultado pelos parâmetros (ponteiros) ou em \textit{sr};
	\item Restaurar registradores \textit{r1} até \textit{r4}, se necessário;
	\item Saltar para \textit{lr} (retorno);
	\end{enumerate}
\item Na função chamadora, restaurar \textit{lr} da pilha;
\item Liberar da pilha os parâmetros.
\end{enumerate}


\chapter{Montagem de código e simulação}
\label{ref:assembler}

\section{Montador}
O montador possui uma sintaxe bastante simples, não sendo necessário definir regiões separadas para código e dados e diretivas tradicionalmente utilizadas em montadores de outras arquiteturas. O programa montador foi descrito com a linguagem Python, em função de sua facilidade natural de manipular texto e poder servir como referência para implementações mais completas e com um desempenho melhor.

\subsection{Formato da linguagem de montagem}

Rótulos são utilizados para declarar pontos específicos (deslocamentos) no código, como destinos de saltos, endereço de entrada de funções ou procedimentos e também endereços de estruturas de dados (variáveis e vetores). O montador é responsável por resolver o valor dos rótulos, permitindo que as referências à memória assumam um valor numérico para a codificação das instruções em linguagem de máquina.

Instruções são representadas por seus mnemônicos, e em sua maioria possuem parâmetros que especificam o modo de endereçamento utilizado (R ou I) e operandos. Os mnemônicos que representam instruções, assim como as referências à registradores, são traduzidos pelo montador. Algumas poucas pseudo-operações não possuem parâmetros, como NOP e HCF. As regras para um programa de montagem válido são:

\begin{itemize}
\item Comentários devem ser iniciados por um caracter ponto e vírgula seguido por um espaço (; ) à esquerda, sem tabulações. Apenas caracteres da língua inglesa são reconhecidos.
\item Rótulos devem ser declarados com alinhamento à esquerda, sem tabulações, e sem finalizador (dois pontos).
\item Instruções devem ser alinhadas à esquerda, com uma única tabulação.
\item Instruções devem ser representadas por dois campos: mnemônico e parâmetros (se existirem). O separador dos dois campos pode ser um espaço ou uma tabulação.
\item Os elementos que compõem parâmetros de uma instrução devem ser separados por vírgula e sem espaços.
\item Rótulos sem parâmetros definem endereços (deslocamentos ou alvo de desvios) no código, e com parâmetros definem estruturas de dados e sua posição inicial na memória.
\item Estruturas de dados são definidas por dois tipos básicos (byte e inteiro). No tipo byte, os valores são representados por um conjunto de bytes e no tipo inteiro podem ser definidos por apenas um valor numérico (variável) ou uma lista de valores separados por um espaço (vetor de inteiros).
\item Valores das estruturas de dados podem ser bytes (\textit{string}) delimitados por aspas ou valores numéricos, representados em decimal (123), hexadecimal (0x123), octal (0o123) ou binário (0b1010).
\item Caracteres especiais aceitos em \textit{strings} são $\backslash t$, $\backslash n$ e $\backslash r$. \textit{Strings} definem implicitamente o terminador \textit{$\backslash 0$}.
\item Instruções e dados podem ser misturados.
\end{itemize}

Para a montagem de código, são realizadas três passadas em sequência. Cada uma possui um papel fundamental na transformação do programa em linguagem de montagem para código de máquina. A sequência para a montagem de um programa com relação às passadas pelo código fonte em linguagem de montagem é a seguinte:

\begin{enumerate}
\item Pseudo-operações são convertidas para operações básicas equivalentes ou sequências (padrões) de instruções suportadas pela arquitetura;
\item Rótulos são resolvidos (convertidos) para endereços e uma tabela de símbolos é montada;
\item Instruções e dados são montados (traduzidos), um a um, a partir da listagem gerada no passo anterior e da tabela de símbolos.
\end{enumerate}

\subsection{Sintaxe de linha de comando}

A entrada e saída padrão devem ser utilizadas para processar um arquivo em linguagem de montagem e armazenar o código objeto gerado. Além disso, o script do montador deve ser invocado com o interpretador Python (versão 2.7):

\begin{verbatim}
$ python assemble16.py < input.asm > output.out
\end{verbatim}

O seguinte código em linguagem de montagem,

\lstinputlisting[caption=ninetoone.asm]{../examples/ninetoone.asm}

após ser processado pelo montador, resulta no seguinte código objeto:

\lstinputlisting[multicols=2,caption=ninetoone.out]{../examples/ninetoone.out}

O arquivo de entrada \textit{input.asm} será processado e o código objeto (pronto para ser executado no simulador) será armazenado em \textit{output.txt}. Uma listagem completa é obtida (para depuração do código, por exemplo), se o script for executado com o parâmetro \textit{debug}:

\begin{verbatim}
$ python assemble16.py debug < input.asm > output.out
\end{verbatim}

O resultado será uma listagem contendo além dos endereços e código objeto, os rótulos e código intermediário do processo de montagem. O simulador não pode executar essa listagem diretamente, no entanto.

\lstinputlisting[multicols=2,caption=ninetoone\_debug.out]{../examples/ninetoone_debug.out}

Caso ocorra algum erro de montagem, o script irá terminar silenciosamente. Erros de montagem podem ser verificados no código objeto gerado, onde nas linhas em que ocorreram erros será apresentado um padrão \texttt{**** ????}. O código objeto resultante será rejeitado pelo simulador caso exista algum erro na montagem.

Diversos arquivos de código fonte podem ser combinados (concatenados) e usados como uma única entrada para o montador. A sintaxe é:

\begin{verbatim}
$ cat fonte1.asm fonte2.asm fonte3.asm | python assemble16.py > output.out
\end{verbatim}

\section{Simulador}

Assim como o programa montador, o simulador foi implementado na linguagem Python. Apesar da simulação ser bastante lenta em função do interpretador Python, a descrição mostrou-se adequada para a verificação do comportamento da arquitetura. Esse implementação de referência é simples de ser entendida, o que permite um porte fácil do simulador para outras linguagens de alto desempenho (como C, por exemplo).

\subsection{Mapa de memória}

O simulador implementa o modelo de execução da arquitetura Viking, incluindo uma memória e mecanismos básicos de entrada e saída. O espaço de endereçamento é compartilhado entre dados e instruções, por questões de simplicidade. Os espaços de endereçamento possuem algumas diferenças entre os simuladores da arquitetura de 16 e 32 bits.

\begin{table}[ht!]
\centering
\begin{tabular}{|p{5.0cm}|p{3.0cm}|p{3.0cm}|}
\hline
\bf{Papel} 		& \bf{16 bits} 		& \bf{32 bits}		\\ \hline \hline
Código + dados (início)	& \texttt{0x0000}	& \texttt{0x00000000}	\\ \hline
Ponteiro de pilha	& \texttt{0xdffe}	& \texttt{0x000ffffc}	\\ \hline
Saída (caracter)	& \texttt{0xf000}	& \texttt{0xf0000000}	\\ \hline
Saída (inteiro)		& \texttt{0xf002}	& \texttt{0xf0000004}	\\ \hline
Entrada (caracter)	& \texttt{0xf004}	& \texttt{0xf0000008}	\\ \hline
Entrada (inteiro)	& \texttt{0xf006}	& \texttt{0xf000000c}	\\ \hline
\end{tabular}
\end{table}

No início da simulação, o ponteiro de pilha (\textit{sp}) é inicializado para o topo da pilha, que coindide com o final da memória. A execução do programa começa a partir do endereço zero, após o programa ser carregado para a memória.

\subsection{Sintaxe de linha de comando}

Assim como o montador, a entrada e saída padrão são usadas pelo simulador para a leitura do código objeto e dispositivos de entrada e saída apresentados no mapa de memória. Para a execução de um programa, o simulador deve ser invocado da seguinte forma:

\begin{verbatim}
$ python run16.py < output.out

[program (code + data): 38 bytes]
[memory size: 57344]
9 8 7 6 5 4 3 2 1
[ok]
112 cycles
\end{verbatim}

Nesse caso, \textit{output.out} foi gerado no processo de montagem e é usado como entrada para o simulador. Caso seja necessário executar o programa instrução por instrução, pode-se usar o parâmetro \textit{debug}:

\begin{verbatim}
$ python run16.py debug < output.out
\end{verbatim}

Case seja necessário montar o programa e executá-lo no simulador, é possível invocar o montador e direcionar sua saída à entrada do simulador, através de um \textit{pipe}. Com isso, evita-se a necessidade de criação de um arquivo intermediário, e pode-se executar o programa a partir de seu código de montagem:

\begin{verbatim}
$ python assemble16.py < input.asm | python run16.py
\end{verbatim}

\appendix

\chapter{Exemplos}

\lstinputlisting[multicols=2,caption=hello\_world.asm]{../examples/hello_world.asm}
\lstinputlisting[multicols=2,caption=fibonacci.asm]{../examples/fibonacci.asm}
\lstinputlisting[multicols=2,caption=function\_call.asm]{../examples/function_call.asm}
\lstinputlisting[multicols=2,caption=mult.asm]{../examples/mult.asm}
\lstinputlisting[multicols=2,caption=bubble\_sort.asm]{../examples/bubble_sort.asm}

\chapter{Rotinas \textit{mulsi3}, \textit{divsi3}, \textit{modsi3} e \textit{udivmodsi4}}
\label{ref:muldiv}

\lstinputlisting[multicols=2,caption=mulsi3.asm]{../examples/mulsi3.asm}
\lstinputlisting[multicols=2,caption=divsi3.asm]{../examples/divsi3.asm}
\lstinputlisting[multicols=2,caption=modsi3.asm]{../examples/modsi3.asm}
\lstinputlisting[multicols=2,caption=udivmodsi4.asm]{../examples/udivmodsi4.asm}

\end{document}
